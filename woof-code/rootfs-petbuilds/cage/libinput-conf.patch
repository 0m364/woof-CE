From 5f83e17c3ab4891f82855201f9699ef56734714b Mon Sep 17 00:00:00 2001
From: Dima Krasner <dima@dimakrasner.com>
Date: Sun, 16 May 2021 18:01:49 +0300
Subject: [PATCH] seat: optionally enable touchpad tap and natural scroll using
 environment variables

---
 seat.c | 56 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 56 insertions(+)

diff --git a/seat.c b/seat.c
index 08f25a3..db1413e 100644
--- a/seat.c
+++ b/seat.c
@@ -9,9 +9,11 @@
 #include "config.h"
 
 #include <linux/input-event-codes.h>
+#include <libinput.h>
 #include <stdlib.h>
 #include <wayland-server-core.h>
 #include <wlr/backend.h>
+#include <wlr/backend/libinput.h>
 #include <wlr/backend/multi.h>
 #include <wlr/types/wlr_cursor.h>
 #include <wlr/types/wlr_data_device.h>
@@ -195,6 +197,57 @@ handle_pointer_destroy(struct wl_listener *listener, void *data)
 	update_capabilities(seat);
 }
 
+static bool
+is_enabled(const char *key, bool def)
+{
+	const char *val = getenv(key);
+	return (
+		(def && (!val || (val[0] && (val[1] != '0')))) ||
+		(!def && (val && val[0] && (val[1] != '0')))
+	);
+}
+
+static void
+set_tap(struct wlr_input_device *device)
+{
+	enum libinput_config_tap_state state = LIBINPUT_CONFIG_TAP_ENABLED;
+	struct libinput_device *libinput_device;
+	enum libinput_config_status status;
+
+	if (is_enabled("LIBINPUT_DEFAULT_TAP", true)) {
+		state = LIBINPUT_CONFIG_TAP_DISABLED;
+	}
+
+	libinput_device = wlr_libinput_get_device_handle(device);
+
+	status = libinput_device_config_tap_set_enabled(libinput_device, state);
+	if (status != LIBINPUT_CONFIG_STATUS_SUCCESS) {
+		wlr_log(WLR_ERROR, "Failed to set tap-to-click state for '%s': %s", libinput_device_get_name(libinput_device), libinput_config_status_to_str(status));
+	}
+}
+
+static void
+set_natural_scroll(struct wlr_input_device *device)
+{
+	int enable;
+	struct libinput_device *libinput_device;
+	enum libinput_config_status status;
+
+	if (is_enabled("LIBINPUT_DEFAULT_NATURAL_SCROLL", false)) {
+		enable = 1;
+	}
+
+	libinput_device = wlr_libinput_get_device_handle(device);
+
+	if (!libinput_device_config_scroll_has_natural_scroll(libinput_device)) {
+		return;
+	}
+
+	status = libinput_device_config_scroll_set_natural_scroll_enabled(libinput_device, enable);
+	if (status != LIBINPUT_CONFIG_STATUS_SUCCESS) {
+		wlr_log(WLR_ERROR, "Failed to set natural scroll state for '%s': %s", libinput_device_get_name(libinput_device), libinput_config_status_to_str(status));
+	}
+}
 static void
 handle_new_pointer(struct cg_seat *seat, struct wlr_input_device *device)
 {
@@ -204,6 +257,9 @@ handle_new_pointer(struct cg_seat *seat, struct wlr_input_device *device)
 		return;
 	}
 
+	set_tap(device);
+	set_natural_scroll(device);
+
 	pointer->seat = seat;
 	pointer->device = device;
 	wlr_cursor_attach_input_device(seat->cursor, device);
-- 
2.25.1

