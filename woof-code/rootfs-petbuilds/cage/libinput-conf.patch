From 3d819ed8fbf81b65cf4daabc57b52fbb26bcd642 Mon Sep 17 00:00:00 2001
From: Dima Krasner <dima@dimakrasner.com>
Date: Mon, 17 May 2021 09:16:20 +0300
Subject: [PATCH] seat: add support for pointer device configuration using
 environment variables

---
 meson.build |   2 +
 seat.c      | 133 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 135 insertions(+)

diff --git a/meson.build b/meson.build
index a268f1a..0669e32 100644
--- a/meson.build
+++ b/meson.build
@@ -39,6 +39,7 @@ wayland_protos = dependency('wayland-protocols', version: '>=1.14')
 wayland_server = dependency('wayland-server')
 pixman         = dependency('pixman-1')
 xkbcommon      = dependency('xkbcommon')
+libinput       = dependency('libinput')
 math           = cc.find_library('m')
 
 wl_protocol_dir = wayland_protos.get_pkgconfig_variable('pkgdatadir')
@@ -158,6 +159,7 @@ executable(
     wlroots,
     xkbcommon,
     pixman,
+    libinput,
     math,
   ],
   install: true,
diff --git a/seat.c b/seat.c
index 08f25a3..18569fd 100644
--- a/seat.c
+++ b/seat.c
@@ -9,9 +9,12 @@
 #include "config.h"
 
 #include <linux/input-event-codes.h>
+#include <libinput.h>
 #include <stdlib.h>
+#include <errno.h>
 #include <wayland-server-core.h>
 #include <wlr/backend.h>
+#include <wlr/backend/libinput.h>
 #include <wlr/backend/multi.h>
 #include <wlr/types/wlr_cursor.h>
 #include <wlr/types/wlr_data_device.h>
@@ -195,6 +198,131 @@ handle_pointer_destroy(struct wl_listener *listener, void *data)
 	update_capabilities(seat);
 }
 
+static bool
+is_enabled(const char *val, bool def)
+{
+	return (
+		(def && (!val || !val[0] || (val[0] != '0'))) ||
+		(!def && (val && val[0] && (val[0] != '0')))
+	);
+}
+
+static void
+set_tap(struct wlr_input_device *device)
+{
+	const char *val;
+	enum libinput_config_tap_state state = LIBINPUT_CONFIG_TAP_ENABLED;
+	struct libinput_device *libinput_device;
+	enum libinput_config_status status;
+
+	val = getenv("LIBINPUT_DEFAULT_TAP");
+	if (!val || !val[0]) {
+		return;
+	}
+
+	if (!is_enabled(val, true)) {
+		state = LIBINPUT_CONFIG_TAP_DISABLED;
+	}
+
+	libinput_device = wlr_libinput_get_device_handle(device);
+
+	status = libinput_device_config_tap_set_enabled(libinput_device, state);
+	if (status != LIBINPUT_CONFIG_STATUS_SUCCESS) {
+		wlr_log(WLR_ERROR, "Failed to set tap-to-click state for '%s': %s", libinput_device_get_name(libinput_device), libinput_config_status_to_str(status));
+	}
+}
+
+static void
+set_natural_scroll(struct wlr_input_device *device)
+{
+	const char *val;
+	int enable = 0;
+	struct libinput_device *libinput_device;
+	enum libinput_config_status status;
+
+	val = getenv("LIBINPUT_DEFAULT_NATURAL_SCROLL");
+	if (!val || !val[0]) {
+		return;
+	}
+
+	if (is_enabled(val, false)) {
+		enable = 1;
+	}
+
+	libinput_device = wlr_libinput_get_device_handle(device);
+
+	if (!libinput_device_config_scroll_has_natural_scroll(libinput_device)) {
+		return;
+	}
+
+	status = libinput_device_config_scroll_set_natural_scroll_enabled(libinput_device, enable);
+	if (status != LIBINPUT_CONFIG_STATUS_SUCCESS) {
+		wlr_log(WLR_ERROR, "Failed to set natural scroll state for '%s': %s", libinput_device_get_name(libinput_device), libinput_config_status_to_str(status));
+	}
+}
+
+static void
+set_acceleration(struct wlr_input_device *device)
+{
+	const char *val;
+	double accel = 0;
+	char *end = NULL;
+	struct libinput_device *libinput_device;
+	enum libinput_config_status status;
+
+	val = getenv("LIBINPUT_DEFAULT_ACCELERATION");
+	if (!val || !val[0]) {
+		return;
+	}
+
+	errno = 0;
+	accel = strtod(val, &end);
+	if (errno || (end && *end) || (accel < -1) || (accel > 1)) {
+		return;
+	}
+
+	libinput_device = wlr_libinput_get_device_handle(device);
+
+	if (!libinput_device_config_accel_is_available(libinput_device)) {
+		return;
+	}
+
+	status = libinput_device_config_accel_set_speed(libinput_device, accel);
+	if (status != LIBINPUT_CONFIG_STATUS_SUCCESS) {
+		wlr_log(WLR_ERROR, "Failed to set acceleration for '%s': %s", libinput_device_get_name(libinput_device), libinput_config_status_to_str(status));
+	}
+}
+
+static void
+set_scroll_method(struct wlr_input_device *device)
+{
+	const char *val;
+	enum libinput_config_scroll_method method = LIBINPUT_CONFIG_SCROLL_2FG;
+	long l;
+	char *end = NULL;
+	struct libinput_device *libinput_device;
+	enum libinput_config_status status;
+
+	val = getenv("LIBINPUT_DEFAULT_SCROLL_METHOD");
+	if (!val || !val[0]) {
+		return;
+	}
+
+	errno = 0;
+	l = strtol(val, &end, 10);
+	if (errno || (end && *end) || ((method != LIBINPUT_CONFIG_SCROLL_NO_SCROLL) && (method != LIBINPUT_CONFIG_SCROLL_2FG) && (method != LIBINPUT_CONFIG_SCROLL_EDGE) && (method != LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN))) {
+		return;
+	}
+	method = (enum libinput_config_scroll_method)l;
+
+	libinput_device = wlr_libinput_get_device_handle(device);
+
+	status = libinput_device_config_scroll_set_method(libinput_device, method);
+	if (status != LIBINPUT_CONFIG_STATUS_SUCCESS) {
+		wlr_log(WLR_ERROR, "Failed to set scroll method for '%s': %s", libinput_device_get_name(libinput_device), libinput_config_status_to_str(status));
+	}
+}
+
 static void
 handle_new_pointer(struct cg_seat *seat, struct wlr_input_device *device)
 {
@@ -204,6 +332,11 @@ handle_new_pointer(struct cg_seat *seat, struct wlr_input_device *device)
 		return;
 	}
 
+	set_tap(device);
+	set_natural_scroll(device);
+	set_acceleration(device);
+	set_scroll_method(device);
+
 	pointer->seat = seat;
 	pointer->device = device;
 	wlr_cursor_attach_input_device(seat->cursor, device);
-- 
2.25.1

